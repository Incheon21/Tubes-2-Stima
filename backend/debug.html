d/debug.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Little Alchemy 2 Recipe Debugger</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            flex-direction: row;
            gap: 20px;
        }
        .panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        .control-panel {
            flex: 1;
            max-width: 400px;
        }
        .visualization-panel {
            flex: 2;
        }
        h2 {
            margin-top: 0;
            color: #333;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            margin-right: 8px;
            margin-bottom: 8px;
        }
        button:hover {
            background-color: #45a049;
        }
        #log {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #f9f9f9;
            font-family: monospace;
            margin-bottom: 15px;
        }
        .stats {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }
        .stat-box {
            flex: 1;
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
            background: #f0f0f0;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin: 5px 0;
        }
        .debug {
            color: #777;
        }
        .error {
            color: #d32f2f;
        }
        .success {
            color: #388e3c;
        }
        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 2px;
        }
        .node text {
            font: 12px sans-serif;
        }
        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }
        #visualization {
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            overflow: auto;
        }
        #recipe-details {
            margin-top: 15px;
        }
        .recipe-path {
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        .recipe-step {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .plus {
            margin: 0 10px;
            font-weight: bold;
            font-size: 18px;
        }
        .element-box {
            background: #e1f5fe;
            border: 1px solid #81d4fa;
            padding: 5px 10px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .base-element {
            background: #fff9c4;
            border: 1px solid #fff176;
        }
        .result-element {
            background: #c8e6c9;
            border: 1px solid #81c784;
        }
        .tree-selector {
            margin: 10px 0;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
            text-align: center;
        }
        .tree-selector button {
            margin: 0 5px;
        }
        .active-button {
            background-color: #2196F3 !important;
        }
        .tree-container {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fafafa;
        }
        .tree-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .element-image {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }
        .test-connection-panel {
            margin-bottom: 15px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Little Alchemy 2 Recipe Debugger</h1>
    
    <div class="container">
        <div class="control-panel panel">
            <h2>Recipe Tree Visualization</h2>
            
            <div class="test-connection-panel">
                <div class="form-group">
                    <label for="serverUrl">Server URL:</label>
                    <input type="text" id="serverUrl" value="http://localhost:8080" placeholder="e.g., http://localhost:8080">
                </div>
                <button id="testConnBtn">Test Connection</button>
            </div>
            
            <div class="form-group">
                <label for="target">Target Element:</label>
                <input type="text" id="target" placeholder="e.g., Brick">
            </div>
            
            <div class="form-group">
                <label for="treeType">Tree Type:</label>
                <select id="treeType">
                    <option value="best-recipes-tree">Best Recipe Tree</option>
                    <option value="multiple-recipes-tree">Multiple Recipe Trees</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="treeCount">Number of Trees:</label>
                <input type="number" id="treeCount" value="3" min="1" max="5">
            </div>
            
            <button id="visualizeBtn">Visualize Recipe Trees</button>
            <button id="clearBtn">Clear Visualization</button>
            
            <h2>Debug Log</h2>
            <div id="log"></div>
            
            <div class="stats">
                <div class="stat-box">
                    <div>Time (ms)</div>
                    <div class="stat-value" id="time-stat">0</div>
                </div>
                <div class="stat-box">
                    <div>Nodes Visited</div>
                    <div class="stat-value" id="nodes-stat">0</div>
                </div>
                <div class="stat-box">
                    <div>Trees Found</div>
                    <div class="stat-value" id="trees-stat">0</div>
                </div>
            </div>
        </div>
        
        <div class="visualization-panel panel">
            <h2>Tree Visualization</h2>
            
            <div id="tree-selector" class="tree-selector" style="display: none;">
                <!-- Tree selector buttons will be added here -->
            </div>
            
            <div id="visualization"></div>
            
            <div id="recipe-details">
                <!-- Recipe details will be shown here -->
            </div>
        </div>
    </div>

    <script>
        // Elements cache
        let allElements = [];
        let currentTrees = [];
        let currentTreeIndex = 0;
        
        // Get server URL
        function getServerUrl() {
            return document.getElementById('serverUrl').value.trim();
        }
        
        // Log function
        function log(message, type = 'debug') {
            const logElement = document.getElementById('log');
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
        }

        // Test connection button
        document.getElementById('testConnBtn').addEventListener('click', async () => {
            const serverUrl = getServerUrl();
            log(`Testing connection to ${serverUrl}...`);
            
            try {
                const response = await fetch(`${serverUrl}/api/elements`);
                if (response.ok) {
                    log(`Connection successful! Server is running at ${serverUrl}`, 'success');
                    
                    // Try to load elements
                    await loadElements();
                } else {
                    log(`Connection failed: Server responded with status ${response.status}`, 'error');
                }
            } catch (error) {
                log(`Connection failed: ${error.message}`, 'error');
                log('Please check that:');
                log('1. The server is running');
                log('2. The URL is correct');
                log('3. CORS is enabled on the server');
            }
        });

        // Load elements from server
        async function loadElements() {
            try {
                const serverUrl = getServerUrl();
                log('Fetching all elements...');
                const response = await fetch(`${serverUrl}/api/elements`);
                if (!response.ok) {
                    throw new Error(`HTTP Error: ${response.status}`);
                }
                
                allElements = await response.json();
                log(`Successfully loaded ${allElements.length} elements`, 'success');
                
                // Populate target datalist
                const uniqueTargets = [...new Set(allElements.map(e => e.name))].sort();
                
                // Remove existing datalist if any
                const existingDatalist = document.getElementById('element-list');
                if (existingDatalist) {
                    existingDatalist.remove();
                }
                
                const datalist = document.createElement('datalist');
                datalist.id = 'element-list';
                
                uniqueTargets.forEach(target => {
                    const option = document.createElement('option');
                    option.value = target;
                    datalist.appendChild(option);
                });
                
                document.body.appendChild(datalist);
                document.getElementById('target').setAttribute('list', 'element-list');
                return true;
            } catch (error) {
                log(`Failed to fetch elements: ${error.message}`, 'error');
                return false;
            }
        }

        // Fetch all elements when page loads
        window.addEventListener('DOMContentLoaded', async () => {
            try {
                await loadElements();
            } catch (error) {
                log('Could not automatically load elements on page load.', 'debug');
                log('Use the "Test Connection" button to connect to the server.', 'debug');
            }
        });
        
        // Visualize button click handler
        document.getElementById('visualizeBtn').addEventListener('click', async () => {
            const serverUrl = getServerUrl();
            const target = document.getElementById('target').value;
            const treeType = document.getElementById('treeType').value;
            const treeCount = parseInt(document.getElementById('treeCount').value);
            
            if (!target) {
                log('Please enter a target element', 'error');
                return;
            }
            
            try {
                log(`Fetching ${treeType} for ${target}...`);
                
                const url = `${serverUrl}/api/${treeType}/${encodeURIComponent(target)}?count=${treeCount}`;
                log(`Requesting URL: ${url}`);
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP Error: ${response.status}`);
                }
                
                const result = await response.json();
                log('Data received successfully', 'success');
                
                // Update stats
                document.getElementById('time-stat').textContent = result.timeElapsed || 0;
                document.getElementById('nodes-stat').textContent = result.nodesVisited || 0;
                
                if (!result.trees || result.trees.length === 0) {
                    log(`No recipe trees found for ${target}`, 'error');
                    document.getElementById('visualization').innerHTML = '<div style="padding: 20px; text-align: center;">No recipe trees found</div>';
                    document.getElementById('tree-selector').style.display = 'none';
                    document.getElementById('recipe-details').innerHTML = '';
                    document.getElementById('trees-stat').textContent = 0;
                    return;
                }
                
                // Store the trees for navigation
                currentTrees = result.trees;
                currentTreeIndex = 0;
                
                // Update trees count
                document.getElementById('trees-stat').textContent = currentTrees.length;
                
                log(`Found ${currentTrees.length} recipe trees for ${target}`, 'success');
                
                // Setup tree selector if multiple trees
                setupTreeSelector(currentTrees.length);
                
                // Visualize the first tree
                visualizeTree(currentTrees[0], target);
                
            } catch (error) {
                log(`Visualization failed: ${error.message}`, 'error');
            }
        });
        
        // Clear button click handler
        document.getElementById('clearBtn').addEventListener('click', () => {
            document.getElementById('visualization').innerHTML = '';
            document.getElementById('recipe-details').innerHTML = '';
            document.getElementById('tree-selector').style.display = 'none';
            currentTrees = [];
            currentTreeIndex = 0;
            
            // Reset stats
            document.getElementById('time-stat').textContent = 0;
            document.getElementById('nodes-stat').textContent = 0;
            document.getElementById('trees-stat').textContent = 0;
            
            log('Visualization cleared');
        });
        
        // Setup tree selector buttons
        function setupTreeSelector(treeCount) {
            const selector = document.getElementById('tree-selector');
            selector.innerHTML = '';
            
            if (treeCount <= 1) {
                selector.style.display = 'none';
                return;
            }
            
            selector.style.display = 'block';
            
            for (let i = 0; i < treeCount; i++) {
                const button = document.createElement('button');
                button.textContent = `Tree ${i + 1}`;
                button.dataset.index = i;
                if (i === 0) button.classList.add('active-button');
                
                button.addEventListener('click', (e) => {
                    // Update active button
                    document.querySelectorAll('#tree-selector button').forEach(btn => {
                        btn.classList.remove('active-button');
                    });
                    e.target.classList.add('active-button');
                    
                    // Update tree display
                    const index = parseInt(e.target.dataset.index);
                    currentTreeIndex = index;
                    visualizeTree(currentTrees[index], document.getElementById('target').value);
                });
                
                selector.appendChild(button);
            }
        }
        
        // Visualize a recipe tree using D3.js
        function visualizeTree(treeData, targetElement) {
            // Clear previous visualization
            document.getElementById('visualization').innerHTML = '';
            
            // Set up dimensions
            const margin = {top: 40, right: 90, bottom: 50, left: 90};
            const width = 960 - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;
            
            // Create SVG
            const svg = d3.select("#visualization")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Add title
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", -20)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .style("font-weight", "bold")
                .text(`Recipe Tree for ${targetElement}`);
            
            // Process the data for d3 hierarchy
            const hierarchyData = processTreeData(treeData);
            
            // Create tree layout
            const treeLayout = d3.tree().size([height, width]);
            
            // Convert data to hierarchy
            const root = d3.hierarchy(hierarchyData);
            
            // Assign x and y coordinates
            treeLayout(root);
            
            // Add links
            svg.selectAll(".link")
                .data(root.links())
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("d", d => {
                    return `M${d.target.y},${d.target.x}
                            C${(d.source.y + d.target.y) / 2},${d.target.x}
                             ${(d.source.y + d.target.y) / 2},${d.source.x}
                             ${d.source.y},${d.source.x}`;
                });
            
            // Add nodes
            const node = svg.selectAll(".node")
                .data(root.descendants())
                .enter()
                .append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.y},${d.x})`);
            
            // Add node circles
            node.append("circle")
                .attr("r", 10)
                .style("fill", d => {
                    if (d.data.isBaseElement) return "#FFC107";
                    if (d.depth === 0) return "#4CAF50"; // Root node
                    return "lightsteelblue";
                });
            
            // Add node labels
            node.append("text")
                .attr("dy", ".35em")
                .attr("x", d => d.children ? -13 : 13)
                .style("text-anchor", d => d.children ? "end" : "start")
                .text(d => d.data.name);
            
            // Show detail panel for the tree
            showTreeDetails(treeData);
        }
        
        // Convert API tree format to D3 hierarchy format
        // ...existing code...
// Convert API tree format to D3 hierarchy format
function processTreeData(treeData) {
    function convertNode(node) {
        const result = {
            name: node.name,
            isBaseElement: node.isBaseElement || false,
            isCircularReference: node.isCircularReference || false,
            noRecipe: node.noRecipe || false,
            imagePath: node.imagePath || null,
            children: []
        };
        
        if (node.ingredients && Array.isArray(node.ingredients)) {
            // Always include all ingredients, even if they're circular references
            result.children = node.ingredients.map(ing => convertNode(ing));
        }
        
        return result;
    }
    
    return convertNode(treeData);
}

// Show detailed tree information
function showTreeDetails(treeData) {
    const container = document.getElementById('recipe-details');
    container.innerHTML = '<h3>Recipe Tree Details</h3>';
    
    // Create container for tree info
    const treeContainer = document.createElement('div');
    treeContainer.className = 'tree-container';
    
    // Add title for this tree with image
    const treeTitle = document.createElement('div');
    treeTitle.className = 'tree-title';
    
    // Add image if available
    if (treeData.imagePath) {
        const img = document.createElement('img');
        img.src = treeData.imagePath;
        img.alt = treeData.name;
        img.className = 'element-image';
        treeTitle.appendChild(img);
    }
    
    const titleText = document.createElement('span');
    titleText.textContent = `Recipe for ${treeData.name}`;
    treeTitle.appendChild(titleText);
    
    treeContainer.appendChild(treeTitle);
    
    // Function to recursively display the tree
    function displayTree(node, container, depth = 0, visited = new Set()) {
        const nodeDiv = document.createElement('div');
        nodeDiv.style.paddingLeft = `${depth * 20}px`;
        nodeDiv.style.marginBottom = '5px';
        
        // Create element display
        const elementSpan = document.createElement('span');
        elementSpan.className = `element-box ${node.isBaseElement ? 'base-element' : (depth === 0 ? 'result-element' : '')}`;
        
        // Add image if available
        if (node.imagePath) {
            const img = document.createElement('img');
            img.src = node.imagePath;
            img.alt = node.name;
            img.className = 'element-image';
            elementSpan.appendChild(img);
        }
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = node.name;
        elementSpan.appendChild(nameSpan);
        
        nodeDiv.appendChild(elementSpan);
        
        // Add special indicators
        if (node.isCircularReference) {
            const circRef = document.createElement('span');
            circRef.textContent = ' (circular reference)';
            circRef.style.color = '#F44336';
            nodeDiv.appendChild(circRef);
        }
        
        if (node.noRecipe) {
            const noRecipe = document.createElement('span');
            noRecipe.textContent = ' (no recipe)';
            noRecipe.style.color = '#FF9800';
            nodeDiv.appendChild(noRecipe);
        }
        
        container.appendChild(nodeDiv);
        
        // Process ingredients if any
        if (node.ingredients && node.ingredients.length > 0) {
            // Add a "made from" text if this node has ingredients
            if (depth === 0) {
                const madeFrom = document.createElement('div');
                madeFrom.style.paddingLeft = `${depth * 20 + 10}px`;
                madeFrom.textContent = 'Made from:';
                madeFrom.style.fontWeight = 'bold';
                madeFrom.style.marginTop = '5px';
                container.appendChild(madeFrom);
            }
            
            // Recursively display each ingredient - always show, even if circular
            node.ingredients.forEach(ingredient => {
                displayTree(ingredient, container, depth + 1);
            });
        }
    }
    
    // Display the tree
    displayTree(treeData, treeContainer);
    container.appendChild(treeContainer);
}
    </script>
</body>
</html>